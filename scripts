login docker images repo
    docker login covapp.azurecr.io -u 00000000-0000-0000-0000-000000000000 -p $TOKEN


Improvements

add 
    livenessProbe:
        httpGet:
            path: /
            port: http
    readinessProbe:
        httpGet:
            path: /
            port: http


Kubectl

    kubectl get pods --watch --output-watch-events -A --> ver eventos en los pods
    kubectl get events -w --field-selector=type=Warning -A  --> filtar eventos 
    -A todos los namespaces
    kubectl wait --for=condition=ready pod -l foo=bar --> validar si se despliegua bien si no se cumple da timeout
    
    kubectl set env pod/<pod_id> --list

    kubectl top pods --sort-by='memory' --> uso de recursos pod ordenados 


    $ kubectl describe pod podname

    $ kubect logs podname –all-containers

    $ kubectl get events --field-selector involvedObject.name=podname

    minikube addons enable ingress

    kubectl exec --stdin --tty pod_name -- /bin/bash


    CRD --> Custom Resources Definition Le enseño a kubernetes como manejar recursos custom

port forwarding localhost
    k -n monitoring port-forward grafana-7cc74b46b5-xt229 3000:3000
    k -n jenkins port-forward jenkins-0 8080:8080

    

helm install ingress-nginx ingress-nginx/ingress-nginx \
  --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/



Desafios 
    Implementación del ingress 
        Para tener una IP publica directa y hacer reverse-proxy es necesario implemntar el application gateway
        Luego error 502 -> cada servicio necesita health checks --> liveness y readinessProbe
